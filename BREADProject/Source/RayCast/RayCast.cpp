#include "RayCast.h"
#include "../Source/Graphics/Model/ModelResource.h"
#include "../Source/Graphics/Mesh/Win/Mesh.h"
#include <thread>

#define USESIMD

namespace Bread
{
    namespace FrameWork
    {
        //初期化
        void RayCastCom::Initialize()
        {
            SetID(GetOwner()->GetID());

            hitFlag = false;
            useFlag = true;
            SetStartPosition({ 0.0f,0.0f ,0.0f });
        }

        //更新
        void RayCastCom::Update()
        {
        }

        //描画
        void RayCastCom::Draw()
        {
        }

        //レイとモデルの交差判定
        bool RayCastCom::IntersectRayVsModel()
        {
            using namespace Math;

            std::shared_ptr<Actor>     terain   { targetTarrain->GetOwner()         };
            std::shared_ptr<Transform> transform{ terain->GetComponent<Transform>() };

            for (auto& face : targetFace)
            {
                hitFlag = false;

                Matrix WorldTransform       { transform->GetWorldTransform() };

                Vector3 Start { start };
                Vector3 End   { end   };
                Vector3 Vec   { Vector3Subtract (End       , Start) };
                Vector3 Dir   { Vector3Normalize(Vec)               };
                f32     Length{ Vector3Length   (Vec)               };

                // レイの長さ
                f32 neart{ Length };

                if (face.vertex.size() < 3)continue;
                if (!face.vertex.at(0) || !face.vertex.at(1) || !face.vertex.at(2))continue;
                Vector3 A{ face.vertex.at(0)};
                Vector3 B{ face.vertex.at(1)};
                Vector3 C{ face.vertex.at(2)};

                // 三角形の三辺ベクトルを算出
                Vector3 AB { Vector3Subtract(B, A)};
                Vector3 BC { Vector3Subtract(C, B)};
                Vector3 CA { Vector3Subtract(A, C)};

                // 三角形の法線ベクトルを算出
                Vector3 Normal{ Vector3Cross(AB, BC) };

                // 内積の結果がプラスならば裏向き
                f32 dot{ Vector3Dot(Dir, Normal) };

                if (dot >= 0.0f) continue;// 垂直の場合もスキップする（壁だから？） ※θは90°の時0になるので内積は0になる　内積 = |A||B|cosθ
                                          // 角度に変換して判断するようにすれば、登れる角度と登れない角度を判断して処理できる？

                 // レイと平面の交点を算出
                Vector3 V{ Vector3Subtract(A, Start)   };
                f32     T{ Vector3Dot(V, Normal) / dot }; // xの長さスカラー（交点までの長さ）
                f32     t{ T                           };
                if (t < 0.0f || t > neart) continue;       // 交点までの距離が今までに計算した最近距離より 大きいときはスキップ

                Vector3 Position{ Start + (Dir * T) }; // ベクトルに始点の位置を与える

                // 交点が三角形の内側にあるか判定
                // １つ目
                Vector3 V1    { Vector3Subtract(A     , Position)};
                Vector3 Cross1{ Vector3Cross   (V1    , AB      )};
                f32     Dot1  { Vector3Dot     (Cross1, Normal  )};
                dot = Dot1;
                if (dot < 0.0f) continue;

                // ２つ目
                Vector3 V2    { Vector3Subtract(B, Position)    };
                Vector3 Cross2{ Vector3Cross   (V2, BC)         };
                f32     Dot2  { Vector3Dot     (Cross2, Normal) };
                dot = Dot2;
                if (dot < 0.0f) continue;

                // ３つ目
                Vector3 V3    { Vector3Subtract(C, Position)    };
                Vector3 Cross3{ Vector3Cross   (V3, CA)         };
                f32     Dot3  { Vector3Dot     (Cross3, Normal) };
                dot = Dot3;
                if (dot < 0.0f) continue;

                // 交点と法線を更新
                Vector3 HitPosition{ Position };
                Vector3 HitNormal  { Normal   };
                neart = t;   // 最短距離を更新

                // 外積とその長さｗｐ
                Vector3 WorldCrossVec    { Vector3Subtract(HitPosition  , start         ) };
                f32     WorldCrossLength { Vector3Length  (WorldCrossVec                ) };

                // ヒット情報保存
                if (Vector3Length(Vector3Subtract(end, start)) > WorldCrossLength)
                {
                    hitResult.position = HitPosition;
                    hitResult.normal   = HitNormal;
                    hitResult.distance = WorldCrossLength;
                    hitResult.start    = start;
                    hitResult.end      = end;

                    hitFlag = true;
                    break;
                }
            }

            if (!targetFace.size() || !hitFlag)
            {
                hitResult.position = { 0.0f,0.0f, 0.0f };
                hitResult.normal   = { 0.0f ,0.0f ,0.0f };
                hitResult.distance = 0.0f;
                hitResult.start    = start;
                hitResult.end      = end;
            }
            return hitFlag;
        }
    }
}
